#####################################
# Seurat Helper Functions
# David McKellar
# version 0.0.1
# Last Edited:
#####################################


# Integration helper functions ####
# This is necessary to keep the gene names in the same order for each sample after they are split back apart
extractSampleRNA <- function(seurObj=scMuscle.seurat, sampleID, assay='RNA', slot='data'){
  tmp <- t(as.sparse(GetAssayData(object=seurObj, assay=assay, slot=slot))[,seurObj$sample == sampleID])
  print(dim(tmp))
  # if(nrow(tmp)>0){
  return(as.matrix(tmp))
  # }else{return(c())}
  #colnames(tmpMat) <- NULL #Its a colnames issue!!!
  # return(tmpMat)
  # have to trans the mat because rows/cols are reversed in python ~ t()
}

# Convert a list of seurat objects (generated by SplitObject(mergedSeuratObject)) into the foramt required by scanorama
#
#
scanoramaPrep <- function(
  seurat.list, 
  assay='RNA',
  slot='data', 
  genes=NULL
){
  #TODO: check for assay in seurat.list; if not present pull out the active assay and print what assay is being used
  if(is.null(genes)){
    genes=rownames(seurat.list)
  }
  
  out = list()
  for(i in 1:length(seurat.list)){
    out[[i]] <- as.matrix(
      t(
        GetAssayData(
          object=seurat.list[[i]],
          assay=assay,
          slot=slot
        )#[genes,]
      )
    )
  }
  return(out)
}

# Monocle Wrappers ####

# From Madhav; convert a Seurat (v3) object to a monocle object
#
#
#
seurat3tomonocle <- function(seu, assay='RNA', slot='counts', lowerDetectionLimit = 0, import_all = FALSE) {
  if(class(seu)[1] == 'Seurat') {
    requireNamespace("Seurat")
    data <- GetAssayData(seu, assay = assay, slot = slot)
    data <- data[rowSums(as.matrix(data)) != 0,] # remove zeroes
    pd <- new("AnnotatedDataFrame", data = seu@meta.data)
    
    # remove filtered cells from Seurat
    if(length(setdiff(colnames(data), rownames(pd))) > 0) {
      data <- data[, rownames(pd)]  
    }
    fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))
    fd <- new("AnnotatedDataFrame", data = fData)
    # lowerDetectionLimit <- seu@is.expr
    
    if(all(data == floor(data))) {
      expressionFamily <- negbinomial.size()
    } else if(any(data < 0)){
      expressionFamily <- uninormal()
    } else {
      expressionFamily <- tobit()
    }
    valid_data <- data[, row.names(pd)]
    monocle_cds <- newCellDataSet(data,
                                  phenoData = pd, 
                                  featureData = fd,
                                  lowerDetectionLimit=lowerDetectionLimit,
                                  expressionFamily=expressionFamily)
    if(import_all) {
      if("Monocle" %in% names(seu@misc)) {
        # if(slotNames(lung) == )
        # monocle_cds@reducedDimS = seu@misc$Monocle@reducedDimS 
        # monocle_cds@reducedDimW = seu@misc$Monocle@reducedDimW  
        # monocle_cds@reducedDimA = seu@misc$Monocle@reducedDimA 
        # monocle_cds@reducedDimK = seu@misc$Monocle@reducedDimK 
        # monocle_cds@minSpanningTree = seu@misc$Monocle@minSpanningTree 
        # monocle_cds@cellPairwiseDistances = seu@misc$Monocle@cellPairwiseDistances 
        # monocle_cds@expressionFamily = seu@misc$Monocle@expressionFamily 
        # monocle_cds@dispFitInfo = seu@misc$Monocle@dispFitInfo 
        # monocle_cds@dim_reduce_type = seu@misc$Monocle@dim_reduce_type 
        # monocle_cds@auxOrderingData = seu@misc$Monocle@auxOrderingData 
        # monocle_cds@auxClusteringData = seu@misc$Monocle@auxClusteringData
        # monocle_cds@experimentData = seu@misc$Monocle@experimentData
        # monocle_cds@classVersion = seu@misc$Monocle@.__classVersion__ 
        # monocle_cds@annotation = seu@misc$Monocle@annotation
        # monocle_cds@protocolData = seu@misc$Monocle@protocolData
        # monocle_cds@featureData = seu@misc$Monocle@featureData
        
        # clean all conversion related slots 
        seu@misc$Monocle@auxClusteringData$seurat <- NULL
        seu@misc$Monocle@auxClusteringData$scran <- NULL
        monocle_cds <- seu@misc$Monocle
        mist_list <- seu
      } else {
        # mist_list <- list(ident = ident, 
        #                   project.name = project.name,
        #                   dr = seu@dr,
        #                   assay = seu@assay,
        #                   hvg.info = seu@hvg.info,
        #                   imputed = seu@imputed,
        #                   cell.names = seu@cell.names,
        #                   cluster.tree = seu@cluster.tree,
        #                   snn = seu@snn,
        #                   kmeans = seu@kmeans,
        #                   spatial = seu@spatial,
        #                   misc = seu@misc
        # ) 
        mist_list <- seu
      }
    } else {
      mist_list <- list()
    } 
    # monocle_cds@auxClusteringData$seurat <- mist_list
  } 
  return(monocle_cds)
}

# Basic Seurat Wrappers ####

# Basic function to convert human to mouse gene names
#   From @leonfodoulian (https://github.com/satijalab/seurat/issues/462)
#   https://www.r-bloggers.com/converting-mouse-to-human-gene-names-with-biomart-package/
#
#   x = list of genes to be converted
#   Usage: mouse.genes <- lapply(X = human.genes, ConvertHumanGeneListToMM)
#
ConvertHumanGeneListToMM <- function(x){
  require(biomaRt)
  
  # Load human ensembl attributes
  human = biomaRt::useMart("ensembl", dataset = "hsapiens_gene_ensembl")
  # Load mouse ensembl attributes
  mouse = biomaRt::useMart("ensembl", dataset = "mmusculus_gene_ensembl")
  
  # Link both datasets and retrieve mouse genes from the human genes
  genes.list = biomaRt::getLDS(attributes = c("hgnc_symbol"), 
                               filters = "hgnc_symbol", 
                               values = x , 
                               mart = human, 
                               attributesL = c("mgi_symbol"), 
                               martL = mouse, 
                               uniqueRows = TRUE)
  
  # Get unique names of genes (in case gene names are duplicated)
  mouse.gene.list <- unique(genes.list[, 2])
  
  # # Print the first 6 genes found to the screen
  # print(head(mouse.gene.list))
  return(mouse.gene.list)
}

# Add a new ident seurat metadata filed) based on a list of cell types
#
#     object:     seurat object
#     old.idents: name of the idents metadata you will be assigning cell types to
#     new.idents: vector of cell types, in order of cluster number
#     newName:    string of the new idents name
#
AddCellTypeIdents <- function(seu=NULL, old.name, new.name=NULL, new.idents, verbose=FALSE){
  old.idents = as.vector(names(table(seu[[old.name]])))
  
  if(is.null(new.name)){
    cat("**Need a new.name for the new idents**\n")
  }else{
    seu[[new.name]] <- as.vector(seu[[old.name]])
    for(i in 1:length(old.idents)){
      if(verbose){cat("Adding ", new.idents[i],"...", sep = "")}
      seu[[new.name]][ seu[[new.name]]==old.idents[i] ] <- new.idents[i]
      if(verbose){cat("Done!\n", sep = "")}
    }
  }
  
   return(seu)
  
}

#dplyr option
# colData(cds)$assigned_cell_type = dplyr::recode(colData(cds)$assigned_cell_type,
#                                                 "1"="Germline",
#                                                 "2"="Body wall muscle",
#                                                 "3"="Unclassified neurons",
#                                                 "4"="Vulval precursors",
#                                                 "5"="Failed QC",
#                                                 "6"="Seam cells",
#                                                 "7"="Pharyngeal epithelia",
#                                                 "8"="Coelomocytes",
#                                                 "9"="Am/PH sheath cells",
#                                                 "10"="Failed QC",
#                                                 "11"="Touch receptor neurons",
#                                                 "12"="Intestinal/rectal muscle",
#                                                 "13"="Pharyngeal neurons")

# Modified Seurat Utilities ####
#     CellCycleScoring ####
# Same as base seurat function, but added G0 features.
# Default phase is still G1
#Added default gene sets (for mouse)
CellCycleScoring_G0 <- function(
  object,
  s.features=NULL,
  g2m.features=NULL,
  g0.features=NULL, # DWM
  set.ident = FALSE,
  suffix='', # string to add at the end of meta data names
  ...
) {
  # Default gene sets, from seurat
  if(is.null(s.features)){
    s.features = c("Mcm5","Pcna","Tyms","Fen1","Mcm7","Mcm4","Rrm1","Ung","Gins2","Mcm6","Cdca7",
                   "Dtl","Prim1","Uhrf1","Cenpu","Hells","Rfc2","Polr1b","Nasp","Rad51ap1","Gmnn","Wdr76",
                   "Slbp","Ccne2","Ubr7","Msh2","Rad51","Rrm2","Cdc45","Cdc6","Exo1","Tipin","Dscc1",
                   "Blm","Casp8ap2", "Usp1","Clspn","Pola1","Chaf1b","Mrpl36","E2f8")
  }
  if(is.null(g2m.features)){
    g2m.features = c("Hmgb2","Cdk1","Nusap1", "Ube2c","Birc5","Tpx2","Top2a","Ndc80","Cks2","Nuf2","Cks1b","Mki67",
                     "Tmpo","Cenpf","Tacc3","Pimreg","Smc4","Ccnb2","Ckap2l", "Ckap2","Aurkb","Bub1","Kif11","Anp32e",
                     "Tubb4b","Gtse1","Kif20b","Hjurp","Cdca3","Cdc20","Ttk","Cdc25c","Kif2c","Rangap1", "Ncapd2",
                     "Dlgap5", "Cdca2","Cdca8","Ect2","Kif23","Hmmr","Aurka","Psrc1","Anln","Lbr","Ckap5","Cenpe",
                     "Ctcf","Nek2","G2e3","Gas2l3","Cbx5","Cenpa"  
    )
  }
  if(is.null(g0.features)){
    g0.features = c("Ccnd3","Pdk1","Smarca2","Foxo3","Ezh1","Prdm5","Ptov1","Zfp30","Zbtb20","Phf1",
                    "Ctdsp1","Thra","Tef","Dicer1","Bcas3","Ddx3y","Gabarapl1", "Itm2a","Il18","Zyx",
                    "Ephx1","Clstn1","Gstk1","Ddt","Ivd","Fhl1","Ndrg2","Grina","Pik3r1","Fyn",     
                    "Chkb","Gm44502","Pink1","Ulk2","Dnajb9","Pfdn5","Ctsf","Crim1","Gabbr1","Grb10",  
                    "Bbs2","Rps14","Igf2r","Selenbp2","Selenbp1", "Rnf167","Map1lc3a" 
      
    )
  }
  
  name <- 'Cell.Cycle'
  features <- list('S.Score' = s.features, 'G2M.Score' = g2m.features, 'G0.Score' = g0.features)
  object.cc <- AddModuleScore(
    object = object,
    features = features,
    name = name,
    ctrl = min(vapply(X = features, FUN = length, FUN.VALUE = numeric(length = 1))),
    ...
  )
  cc.columns <- grep(pattern = name, x = colnames(x = object.cc[[]]), value = TRUE)
  cc.scores <- object.cc[[cc.columns]]
  rm(object.cc)
  
  # CheckGC() # Seurat function for garbage collection
  gc()
  
  assignments <- apply(
    X = cc.scores,
    MARGIN = 1,
    FUN = function(scores, first = 'S', second = 'G2M', third='G0', null = 'G1') {
      if(all(scores < 0)){
        return(null)
      }else{
        if(length(which(x = scores == max(scores))) > 1){
          return('Undecided')
        }else{
          return(c(first, second, third)[which(x = scores == max(scores))])
        }
      }
    }
  )
  
  cc.scores <- merge(x = cc.scores, y = data.frame(assignments), by = 0)
  tmp.colnames <- c('rownames', paste0(c('S.Score', 'G2M.Score', 'G0.Score', 'Phase'), '_', suffix))
  colnames(x = cc.scores) <- tmp.colnames
  rownames(x = cc.scores) <- cc.scores$rownames
  cc.scores <- cc.scores[, tmp.colnames[2:5]]
  object[[colnames(x = cc.scores)]] <- cc.scores
  
  if(set.ident){
    object[['old.ident']] <- Idents(object = object)
    Idents(object = object) <- tmp.colnames[5]
  }
  return(object)
}

# v2 has G0 pos and neg regulators, to reduce FPs for G0
CellCycleScoring_G0v2 <- function(
  object,
  calc.G0=T, #whether or not to include G0
  s.features=NULL,
  g2m.features=NULL,
  g0.pos.features=NULL, #DWM
  g0.neg.features=NULL, #DWM
  species='mouse', #DWM
  set.ident = FALSE,
  suffix='G0v2', # string to add at the end of meta data names #DWM
  ...
) {
  # Default gene sets
  if(species=='mouse'){
    
    if(is.null(s.features)){
      s.features = c("Mcm5","Pcna","Tyms","Fen1","Mcm7","Mcm4","Rrm1","Ung","Gins2","Mcm6","Cdca7",
                     "Dtl","Prim1","Uhrf1","Cenpu","Hells","Rfc2","Polr1b","Nasp","Rad51ap1","Gmnn","Wdr76",
                     "Slbp","Ccne2","Ubr7","Msh2","Rad51","Rrm2","Cdc45","Cdc6","Exo1","Tipin","Dscc1",
                     "Blm","Casp8ap2", "Usp1","Clspn","Pola1","Chaf1b","Mrpl36","E2f8")
    }
    if(is.null(g2m.features)){
      g2m.features = c("Hmgb2","Cdk1","Nusap1", "Ube2c","Birc5","Tpx2","Top2a","Ndc80","Cks2","Nuf2","Cks1b","Mki67",
                       "Tmpo","Cenpf","Tacc3","Pimreg","Smc4","Ccnb2","Ckap2l", "Ckap2","Aurkb","Bub1","Kif11","Anp32e",
                       "Tubb4b","Gtse1","Kif20b","Hjurp","Cdca3","Cdc20","Ttk","Cdc25c","Kif2c","Rangap1", "Ncapd2",
                       "Dlgap5", "Cdca2","Cdca8","Ect2","Kif23","Hmmr","Aurka","Psrc1","Anln","Lbr","Ckap5","Cenpe",
                       "Ctcf","Nek2","G2e3","Gas2l3","Cbx5","Cenpa")
    }
    if(is.null(g0.pos.features)){ # Cheung and Rando, Nat Rev Molc Cell Bio, 2013
      g0.pos.features = c("Ccnd3","Pdk1","Smarca2","Foxo3","Ezh1","Prdm5","Ptov1","Zfp30","Zbtb20","Phf1",
                      "Ctdsp1","Thra","Tef","Dicer1","Bcas3","Ddx3y","Gabarapl1", "Itm2a","Il18","Zyx",
                      "Ephx1","Clstn1","Gstk1","Ddt","Ivd","Fhl1","Ndrg2","Grina","Pik3r1","Fyn",     
                      "Chkb","Gm44502","Pink1","Ulk2","Dnajb9","Pfdn5","Ctsf","Crim1","Gabbr1","Grb10",  
                      "Bbs2","Rps14","Igf2r","Selenbp2","Selenbp1", "Rnf167","Map1lc3a")
    }
    if(is.null(g0.neg.features)){ # Cheung and Rando, Nat Rev Molc Cell Bio, 2013
      g0.neg.features = c("Mtch2","Ccne2","Mcm4","Cycs","Ccnb1","Gm10053","Capza1","Rrm2",
                      "Top2a","Hadhb","Birc5","Pgk1","Hat1","Anln","Pcna","Gm10184",
                      "Kpna2","Slc25a5","Ccna2","Idh3a","4933400A11Rik")
    }
  }
  if(species=='human'){
    # Default gene sets, from seurat
    if(is.null(s.features)){
      s.features = cc.genes.updated.2019$s.genes # from Seurat
    }
    if(is.null(g2m.features)){
      g2m.features = cc.genes.updated.2019$g2m.genes # from Seurat
    }
    if(is.null(g0.pos.features)){ # Cheung and Rando, Nat Rev Molc Cell Bio, 2013
      g0.pos.features = c("CCND3", "PDK1", "SMARCA2", "FOXO3", "EZH1", "PRDM5", "PTOV1", "ZFP30", "ZBTB20", "PHF1", 
                      "CTDSP1", "THRA", "TEF", "DICER1", "A930001N09Rik", "BCAS3", "DDX3Y", "GABARAPL1", "GLTSCR2",
                      "ITM2A", "IL18", "ZYX", "EPHX1", "CLSTN1", "GSTK1", "5730403B10Rik", "DDT", "IVD", "FHL1", 
                      "NDRG2", "GRINA", "PIK3R1", "FYN", "CHKB", "PINK1", "ULK2", "DNAJB9", "PFDN5", "CTSF", "CRIM1", 
                      "SEPP1", "GABBR1", "GRB10", "BBS2", "RPS14", "IGF2R", "SELENBP1", "RNF167", "MAP1LC3A"
                      
      )
    }
    if(is.null(g0.neg.features)){ # Cheung and Rando, Nat Rev Molc Cell Bio, 2013
      g0.neg.features = c("ANLN", "BIRC5", "CCNA2", "CCNB1", "CCNE2", "SGOL1", "MCM4", "PCNA", "RRM2", "TOP2A",
                      "CYCS", "MTCH2", "SLC25A5", "H2AFZ", "HAT1", "DDX39", "2810417H13Rik", "CAPZA1", "HADHB",
                      "IDH3A", "KPNA2", "PGK1"
        
      )
    }
  }
  # TODO: check for overlap in gene sets
  #####
  if(calc.G0){
    name <- 'Cell.Cycle'
    features <- list('S.Score' = s.features,
                     'G2M.Score' = g2m.features,
                     'G0.pos.Score' = g0.pos.features,
                     'G0.neg.Score' = g0.neg.features)
    object.cc <- AddModuleScore(
      object = object,
      features = features,
      name = name,
      ctrl = min(vapply(X = features, FUN = length, FUN.VALUE = numeric(length = 1))),
      ...
    )
    cc.columns <- grep(pattern = name, x = colnames(x = object.cc[[]]), value = TRUE)
    cc.scores <- object.cc[[cc.columns]]
    rm(object.cc)
    
    # CheckGC() # Seurat function for garbage collection
    gc()
    
    assignments <- apply(
      X = cc.scores,
      MARGIN = 1,
      FUN = function(scores, first = 'S', second = 'G2M', third='G0', fourth='G1' ,null = 'G1') {
        if(all(scores < 0)){
          return(null)
        }else{
          if(length(which(x = scores == max(scores))) > 1){
            return('Undecided')
          }else{
            return(c(first, second, third, fourth)[which(x = scores == max(scores))])
          }
        }
      }
    )
    
    cc.scores <- merge(x = cc.scores, y = data.frame(assignments), by = 0)
    tmp.colnames <- c('rownames', paste0(c('S.Score', 'G2M.Score', 'G0.pos.Score', 'G0.neg.Score', 'Phase'), '_', suffix))
    colnames(x = cc.scores) <- tmp.colnames
    rownames(x = cc.scores) <- cc.scores$rownames
    cc.scores <- cc.scores[, tmp.colnames[2:length(tmp.colnames)]]
    object[[colnames(x = cc.scores)]] <- cc.scores
    
    if(set.ident){
      object[['old.ident']] <- Idents(object = object)
      Idents(object = object) <- tmp.colnames[length(tmp.colnames)]
    }
    return(object)
  }else{ # retrurn output from base seurat function
    return(
      CellCycleScoring(
        object = object,
        s.features = s.features,
        g2m.features = g2m.features
      )
    )
  }
}

# Plot Wrappers ####
#     Volcano Plot ####

extractNDifGenes <- function(nGenes, difGeneTable){
  # TODO: add positive or negative log_FC functionality
  
  
  clusterNames <- levels(difGeneTable$cluster) #get cluster names ('cluster' is a colname)
  topNdifGenes <- matrix(data='', nrow=nGenes, ncol=3*length(clusterNames)) #ncol is the number of clusters times 3, for pval and logFC
  
  #Iterate through each cluster name and pull out top n genes, adding them to the output table
  for(i in 1:length(clusterNames)){ #Pull out all top genes, cluster by cluster
    temp <- difGeneTable[difGeneTable$cluster==clusterNames[i],] # pull out all values associated with current cluster of interest
    temp <- temp[order(temp$avg_logFC, decreasing = TRUE),] # sort all the info based on logFC values
    
    if(length(temp)<nGenes){ #Just in case the number of dif expressed genes is less than the requested number of genes...
      tmp_nGenes = length(temp) 
      cat('Warning: There were not ', nGenes, ' genes for cluster ', i, '\n', # Print a warning message
          '     Gave ', tmp_nGenes, 'instead... \n')
    }else{
      tmp_nGenes = nGenes
    }
    
    topNdifGenes[,(3*i-2)] <- temp$gene[1:tmp_nGenes] #Add gene names to output
    
    topNdifGenes[,(3*i-1)] <- temp$avg_logFC[1:tmp_nGenes] #Add log vals to output
    
    topNdifGenes[,(3*i)] <- temp$p_val_adj[1:tmp_nGenes] #Add log vals to output
    
  }
  
  columnNames <- c()
  columnNames[seq(1,3*length(clusterNames), 3)] <- clusterNames
  columnNames[seq(2,3*length(clusterNames), 3)] <- 'avg_logFC'
  columnNames[seq(3,3*length(clusterNames), 3)] <- 'p_val_adj'
  
  colnames(topNdifGenes) <- columnNames
  
  
  return(topNdifGenes)
}


# Generate a volcano plot given a table of differentially expressed markers
#
# Inputs:
#     DGEdata: output from FindMarkers()
#     threshVec: a vector with 2 values, that parameterize the classification of genes
#                   the threshold of log_2 fold change for the dot of the gene 
#                   to be represented as the text gene name #CHANGE DESCRIPTION
#
# Outputs:
#
#
DWM_volcano <- function(DGEdata, threshVec=c(0.05, 1),pvalThresh=10^-50, plotTitle='Volcano Plot', 
                        xlim=NULL, ylim=NULL, geneTextSize=0.5){
  #TODO
  #Implement threshVec
  #Switch to ggplot...
  
  if(is.null(rownames(DGEdata))){
    stop("Differential gene expression matrix needs gene names as rownames()...")
  }
  if(plotTitle=='Volcano Plot'){
    cat('Warning: no plot title give...\n')
  }
  
  p_val_adj = DGEdata$p_val_adj
  avg_logFC = DGEdata$avg_logFC
  DGEdata$genes = rownames(DGEdata)
  
  #Make a basic volcano plot
  if(is.null(xlim)&is.null(ylim)){
    with(DGEdata, plot(avg_logFC,
                       -log10(p_val_adj),
                       pch=20,
                       main=plotTitle))
  }else{
    with(DGEdata, plot(avg_logFC, -log10(p_val_adj),
                       pch=20,
                       main=plotTitle,
                       xlim=xlim,
                       ylim=ylim
    ))
  }
  
  abline(v=0, col="black", lty=3, lwd=1.0) #center line
  abline(v=-threshVec[2], col="black", lty=4, lwd=2.0) #logFC threshold
  abline(v=threshVec[2], col="black", lty=4, lwd=2.0) #logFC threshold
  abline(h=-log10(threshVec[1]), col="black", lty=4, lwd=2.0) #pval threshold
  
  #plot(avg_logFC, -log10(padj), pch=20, main=plotTitle, xlim=c(-2.5,2))
  
  # Add colored points: red if padj<0.05, orange of log2FC>1, green if both)
  with(subset(DGEdata, p_val_adj<threshVec[1]), 
       points(avg_logFC, -log10(p_val_adj), pch=20, col="red"))
  with(subset(DGEdata, abs(avg_logFC)>threshVec[2]), 
       points(avg_logFC, -log10(p_val_adj), pch=20, col="orange"))
  with(subset(DGEdata, p_val_adj<threshVec[1] & abs(avg_logFC)>threshVec[2]),
       points(avg_logFC, -log10(p_val_adj), pch=20, col="green"))
  # with(subset(DGEdata, p_val_adj<threshVec[1] & abs(avg_logFC)>threshVec[2]), 
  #      symbols(x=avg_logFC, y=-log10(p_val_adj), circles=(pct.1/10), bg="green"))
  
  # Label points with the textxy function from the calibrate plot
  library(calibrate)
  with(subset(DGEdata, p_val_adj<threshVec[1] & abs(avg_logFC)>threshVec[2]), textxy(avg_logFC, -log10(p_val_adj), labs=genes, cex=geneTextSize)) #green dots
  #with(subset(DGEdata, p_val_adj<threshVec[1] & abs(avg_logFC)<threshVec[2]), textxy(avg_logFC, -log10(p_val_adj), labs=genes, cex=.8)) #red dots
  
}

# Generates a volcano plot, given the output of FindMarkers() from Seurat
#
# markers:
#     the output of FindMarkers()
#expression:
#     gene expression matrix (from a Seurat object)
#
ggVolcano <- function(markers=NULL, expression=NULL,
                      seu=NULL,
                      logFC_filter.low=0.05,
                      logFC_filter.high = 1,
                      neg.log.pval.Thresh=50,
                      pct.thresh = 0.4,
                      plotTitle='Volcano Plot', 
                      pseudocount=10^-300,
                      fill.cols = c("#000000","#a1a1a1","#cf4c59"),
                      xlim=NULL, ylim=NULL, 
                      genes=NULL,
                      gene.text.size=6,  repel=T, nudge_x=-0.1,
                      dot.scale=1,
                      line.width=1,segment.color="gray",
                      pt.size=1, pt.alpha=1){
  # TODO: add split.by - generalize?
  
  require(ggrepel)
  
  if(is.null(rownames(markers))){
    stop("Differential gene expression matrix needs gene names as rownames()...")
  }
  if(plotTitle=='Volcano Plot'){
    cat('Warning: no plot title given...\n')
  }
  
# Build data.frame ####
  df <- data.frame(
    p_val_adj = -log10(markers$p_val_adj+pseudocount),
    avg_logFC = markers$avg_logFC,
    genes = rownames(markers),
    p_val_filter = -log10(markers$p_val_adj+pseudocount)>neg.log.pval.Thresh, # Values that pass p value threshold
    FC_filter.low = abs(markers$avg_logFC)>logFC_filter.low, # values that pass the lower logFC threshold (dots get drawn)
    FC_filter.high= abs(markers$avg_logFC)>logFC_filter.high # values that pass the logFC threshold (gene names get drawn)
  )
  
  if(is.null(seu)){
    df$pct = 
      apply(markers,1, 
            function(X){
              if(as.numeric(X["avg_logFC"])>0){
                (return(as.numeric(X["pct.1"])))
              }else{
                return(as.numeric(X["pct.2"]))
              }
            }
      )
    
    df$expr.filter = df$pct > pct.thresh # which genes to label
  }else{
    #TODO: add in gene expression data
  }
  
# Add colors ####
  df$colors <- rep(x='none', times=length(df$genes))
  df$colors[df$p_val_filter | df$FC_filter.high] <- 'one' 
  df$colors[df$p_val_filter & df$FC_filter.high] <- 'both'
  df$colors <- factor(df$colors,levels=c("none", "one", "both"))
  
cat(table(df$colors=="both" & df$expr.filter)[2], "genes drawn \n")
# Build ggplot object ####
  out.gg <- ggplot(
    data = df,
    aes(x=avg_logFC, y=p_val_adj)
  ) +
    geom_hline(# pval dotted line
      yintercept = neg.log.pval.Thresh, 
      linetype='dashed', color='lightgray', size = line.width
    )  + 
    geom_vline(# logFC dotted line
      xintercept = c(logFC_filter.high, -logFC_filter.high), 
      linetype='dashed', color='lightgray', size = line.width
    ) + 
    geom_vline(xintercept = 0,  color='black', size = line.width) +
    geom_point(
      pch=21, size=pt.size, alpha=pt.alpha,
      aes(
          fill = colors
          # size = pct # scale dot size according to relative pct expression
      )
    ) 
  if(repel){ 
    out.gg <- out.gg + geom_text_repel(
      data=df[df$colors=="both" & df$expr.filter,],
      size=gene.text.size*(5/14), #convert to same scale as normal ggplot 
      segment.size=0.25,
      segment.alpha = 0.8,
      segment.color = segment.color,
      point.padding = 0.4,
      aes(
        label=genes
        # col=colors
        )
    ) 
  }else{
    out.gg <- out.gg + geom_text(
      data=df[df$colors=="both" & df$expr.filter,],
      size=gene.text.size*(5/14), #convert to same scale as normal ggplot 
      # position=position_dodge(width = 1),
      nudge_x = nudge_x,
      aes(
        label=genes
        # col=colors
      )
    ) 
  }
# Finish plot ####
  out.gg <- out.gg +
    labs(
      x="log2_FC",
      y="-log10(adj._p_val)",
      size = "Pct. Expr."
    ) +
    ggtitle(plotTitle) +
    guides(color=FALSE, fill=FALSE) +
    theme_minimal() + 
    theme(
      panel.grid.major = element_blank(), 
      panel.grid.minor = element_blank(), 
      panel.background = element_blank(), 
      axis.line = element_line(colour = "black", size = line.width),
      panel.border = element_rect(color='black', size=line.width, fill=NA),
      plot.title = element_text(face="bold", hjust=0.5)
    ) + 
    scale_fill_manual(values=fill.cols,aesthetics = c("col","fill"))
    
  
  return(out.gg)
}

#


ggVolcano_v2 <- function(markers=NULL, expression=NULL,
                      seu=NULL,
                      logFC_filter = 1,
                      neg.log.pval.Thresh=50,
                      pct.thresh = 0.4,
                      plotTitle='Volcano Plot', 
                      pseudocount=10^-300,
                      fill.cols = c("#000000","#cf4c59","#2c30a8"),
                      xlim=NULL, ylim=NULL, 
                      genes=NULL,
                      gene.text.size=6,  repel=T, nudge_x=-0.1,
                      dot.scale=1,
                      line.width=1,segment.color="gray",
                      pt.size=1, pt.alpha=1){
  # TODO: add split.by - generalize?
  
  require(ggrepel)
  
  if(is.null(rownames(markers))){
    stop("Differential gene expression matrix needs gene names as rownames()...")
  }
  if(plotTitle=='Volcano Plot'){
    cat('Warning: no plot title given...\n')
  }
  
  # Build data.frame ####
  df <- data.frame(
    p_val_adj = -log10(markers$p_val_adj+pseudocount),
    avg_log2FC = markers$avg_log2FC,
    genes = rownames(markers),
    p_val_filter = -log10(markers$p_val_adj+pseudocount)>neg.log.pval.Thresh, # Values that pass p value threshold
    FC_filter.low = markers$avg_log2FC < -1*logFC_filter, 
    FC_filter.high= markers$avg_log2FC > logFC_filter 
  )
  
  if(is.null(seu)){
    df$pct = 
      apply(markers,1, 
            function(X){
              if(as.numeric(X["avg_log2FC"])>0){
                (return(as.numeric(X["pct.1"])))
              }else{
                return(as.numeric(X["pct.2"]))
              }
            }
      )
    
    df$expr.filter = df$pct > pct.thresh # which genes to label
  }else{
    #TODO: add in gene expression data
  }
  
  # Add colors ####
  df$cols <- rep(x='none', times=length(df$genes))
  df$cols[df$p_val_filter & df$FC_filter.high] <- 'high' 
  df$cols[df$p_val_filter & df$FC_filter.low] <- 'low'
  df$cols <- factor(df$cols,levels=c("none", "high", "low"))
  
  cat(table(df$colors!="none" & df$expr.filter)[2], "genes drawn \n")
  # Build ggplot object ####
  out.gg <- ggplot(
    data = df,
    aes(x=avg_log2FC, y=p_val_adj)
  ) +
    geom_hline(# pval dotted line
      yintercept = neg.log.pval.Thresh, 
      linetype='dashed', color='lightgray', size = line.width
    )  + 
    geom_vline(# logFC dotted line
      xintercept = c(logFC_filter, -logFC_filter), 
      linetype='dashed', color='lightgray', size = line.width
    ) + 
    geom_vline(xintercept = 0,  color='black', size = line.width) +
    geom_point(
      pch=21, size=pt.size, alpha=pt.alpha,
      aes(
        fill = cols, col=cols
        # size = pct # scale dot size according to relative pct expression
      )
    ) 
  if(repel){ 
    out.gg <- out.gg + geom_text_repel(
      data=df[df$cols!="none" & df$expr.filter,],
      size=gene.text.size*(5/14), #convert to same scale as normal ggplot 
      segment.size=0.25,
      segment.alpha = 0.8,
      segment.color = segment.color,
      point.padding = 0.4,
      aes(
        label=genes,
        col=cols
      )
    ) 
  }else{
    out.gg <- out.gg + geom_text(
      data=df[df$cols=="both" & df$expr.filter,],
      size=gene.text.size*(5/14), #convert to same scale as normal ggplot 
      # position=position_dodge(width = 1),
      nudge_x = nudge_x,
      aes(
        label=genes,
        col=cols
      )
    ) 
  }
  # Finish plot ####
  out.gg <- out.gg +
    labs(
      x="log2_FC",
      y="-log10(adj._p_val)",
      size = "Pct. Expr."
    ) +
    ggtitle(plotTitle) +
    guides(color=FALSE, fill=FALSE) +
    theme_minimal() + 
    theme(
      panel.grid.major = element_blank(), 
      panel.grid.minor = element_blank(), 
      panel.background = element_blank(), 
      axis.line = element_line(colour = "black", size = line.width),
      panel.border = element_rect(color='black', size=line.width, fill=NA),
      plot.title = element_text(face="bold", hjust=0.5)
    ) + 
    scale_fill_manual(values=fill.cols,aesthetics = c("col","fill"))
  
  
  return(out.gg)
}

#

# monocle3 plotting functions ####

# same as plot_genes_in_pseudotime(), except can pass logcounts
plot_logcounts_in_pseudotime <- function(cds_subset,
                                         assay="logcounts",
                                         min_expr=NULL,
                                         cell_size=0.75,
                                         nrow=NULL,
                                         ncol=1,
                                         panel_order=NULL,
                                         color_cells_by="pseudotime",
                                         trend_formula="~ splines::ns(pseudotime, df=3)",
                                         label_by_short_name=TRUE,
                                         vertical_jitter=NULL,
                                         horizontal_jitter=NULL){
  assertthat::assert_that(methods::is(cds_subset, "cell_data_set"))
  tryCatch({pseudotime(cds_subset)}, error = function(x) {
    stop(paste("No pseudotime calculated. Must call order_cells first."))})
  colData(cds_subset)$pseudotime <- pseudotime(cds_subset)
  if(!is.null(min_expr)) {
    assertthat::assert_that(assertthat::is.number(min_expr))
  }
  assertthat::assert_that(assertthat::is.number(cell_size))
  
  if(!is.null(nrow)) {
    assertthat::assert_that(assertthat::is.count(nrow))
  }
  
  assertthat::assert_that(assertthat::is.count(ncol))
  assertthat::assert_that(is.logical(label_by_short_name))
  if (label_by_short_name) {
    assertthat::assert_that("gene_short_name" %in% names(rowData(cds_subset)),
                            msg = paste("When label_by_short_name = TRUE,",
                                        "rowData must have a column of gene",
                                        "names called gene_short_name."))
  }
  assertthat::assert_that(color_cells_by %in% c("cluster", "partition") |
                            color_cells_by %in% names(colData(cds_subset)),
                          msg = paste("color_cells_by must be a column in the",
                                      "colData table."))
  
  if(!is.null(panel_order)) {
    if (label_by_short_name) {
      assertthat::assert_that(all(panel_order %in%
                                    rowData(cds_subset)$gene_short_name))
    } else {
      assertthat::assert_that(all(panel_order %in%
                                    row.names(rowData(cds_subset))))
    }
  }
  assertthat::assert_that(nrow(rowData(cds_subset)) <= 100,
                          msg = paste("cds_subset has more than 100 genes -",
                                      "pass only the subset of the CDS to be",
                                      "plotted."))
  
  assertthat::assert_that(methods::is(cds_subset, "cell_data_set"))
  assertthat::assert_that("pseudotime" %in% names(colData(cds_subset)),
                          msg = paste("pseudotime must be a column in",
                                      "colData. Please run order_cells",
                                      "before running",
                                      "plot_genes_in_pseudotime."))
  if(!is.null(min_expr)) {
    assertthat::assert_that(assertthat::is.number(min_expr))
  }
  assertthat::assert_that(assertthat::is.number(cell_size))
  assertthat::assert_that(!is.null(size_factors(cds_subset)))
  if(!is.null(nrow)) {
    assertthat::assert_that(assertthat::is.count(nrow))
  }
  
  assertthat::assert_that(assertthat::is.count(ncol))
  assertthat::assert_that(is.logical(label_by_short_name))
  if (label_by_short_name) {
    assertthat::assert_that("gene_short_name" %in% names(rowData(cds_subset)),
                            msg = paste("When label_by_short_name = TRUE,",
                                        "rowData must have a column of gene",
                                        "names called gene_short_name."))
  }
  assertthat::assert_that(color_cells_by %in% c("cluster", "partition") |
                            color_cells_by %in% names(colData(cds_subset)),
                          msg = paste("color_cells_by must be a column in the",
                                      "colData table."))
  
  if(!is.null(panel_order)) {
    if (label_by_short_name) {
      assertthat::assert_that(all(panel_order %in%
                                    rowData(cds_subset)$gene_short_name))
    } else {
      assertthat::assert_that(all(panel_order %in%
                                    row.names(rowData(cds_subset))))
    }
  }
  assertthat::assert_that(nrow(rowData(cds_subset)) <= 100,
                          msg = paste("cds_subset has more than 100 genes -",
                                      "pass only the subset of the CDS to be",
                                      "plotted."))
  
  f_id <- NA
  Cell <- NA
  cds_subset = cds_subset[,is.finite(colData(cds_subset)$pseudotime)]
  
  cds_exprs <- SingleCellExperiment::counts(cds_subset)
  cds_exprs <- Matrix::t(Matrix::t(cds_exprs)/size_factors(cds_subset))
  cds_exprs <- reshape2::melt(round(as.matrix(cds_exprs)))
  
  # cds_exprs <- normalized_counts(cds_subset) # added by DWM
  # cds_exprs <- reshape2::melt(as.matrix(cds_exprs)) # added by DWM
  
  print(dim(cds_exprs))
  
  if (is.null(min_expr)) {
    min_expr <- 0
  }
  colnames(cds_exprs) <- c("f_id", "Cell", "expression")
  cds_colData <- colData(cds_subset)
  cds_rowData <- rowData(cds_subset)
  
  print(colnames(cds_exprs))
  print(length(rownames(cds_exprs)))
  
  cds_exprs <- merge(cds_exprs, cds_rowData, by.x = "f_id", by.y = "row.names")
  cds_exprs <- merge(cds_exprs, cds_colData, by.x = "Cell", by.y = "row.names")
  
  cds_exprs$adjusted_expression <- cds_exprs$expression
  
  if (label_by_short_name == TRUE) {
    if (is.null(cds_exprs$gene_short_name) == FALSE) {
      cds_exprs$feature_label <- as.character(cds_exprs$gene_short_name)
      cds_exprs$feature_label[is.na(cds_exprs$feature_label)] <- cds_exprs$f_id
    }
    else {
      cds_exprs$feature_label <- cds_exprs$f_id
    }
  }
  else {
    cds_exprs$feature_label <- cds_exprs$f_id
  }
  cds_exprs$f_id <- as.character(cds_exprs$f_id)
  cds_exprs$feature_label <- factor(cds_exprs$feature_label)
  
  
  new_data <- data.frame(pseudotime = colData(cds_subset)$pseudotime)
  model_tbl = fit_models(cds_subset, model_formula_str = trend_formula)
  
  model_expectation <- model_predictions(model_tbl,
                                         new_data = colData(cds_subset))
  
  colnames(model_expectation) <- colnames(cds_subset)
  expectation <- plyr::ddply(cds_exprs, plyr::.(f_id, Cell),
                             function(x) {
                               data.frame(
                                 "expectation"=model_expectation[x$f_id,
                                                                 x$Cell])
                             })
  cds_exprs <- merge(cds_exprs, expectation)
  
  cds_exprs$expression[cds_exprs$expression < min_expr] <- min_expr
  cds_exprs$expectation[cds_exprs$expectation < min_expr] <- min_expr
  if (!is.null(panel_order)) {
    cds_exprs$feature_label <- factor(cds_exprs$feature_label,
                                      levels = panel_order)
  }
  q <- ggplot(aes(pseudotime, expression), data = cds_exprs)
  
  
  if (!is.null(color_cells_by)) {
    q <- q + geom_point(aes_string(color = color_cells_by),
                        size = I(cell_size),
                        position=position_jitter(horizontal_jitter,
                                                 vertical_jitter))
    if (class(colData(cds_subset)[,color_cells_by]) == "numeric"){
      q <- q + viridis::scale_color_viridis(option="C")
    }
  }
  else {
    q <- q + geom_point(size = I(cell_size),
                        position=position_jitter(horizontal_jitter,
                                                 vertical_jitter))
  }
  
  q <- q + geom_line(aes(x = pseudotime, y = expectation), data = cds_exprs)
  
  q <- q + scale_y_log10() + facet_wrap(~feature_label, nrow = nrow,
                                        ncol = ncol, scales = "free_y")
  if (min_expr < 1) {
    q <- q + expand_limits(y = c(min_expr, 1))
  }
  
  q <- q + ylab("Expression")
  
  q <- q + xlab("pseudotime")
  q <- q + monocle_theme_opts()
  q
}

#
plot_logcounts_in_pseudotime <- function(cds_subset,
                                         assay="logcounts",
                                         min_expr=NULL,
                                         cell_size=0.75,
                                         nrow=NULL,
                                         ncol=1,
                                         ncores=1,
                                         # panel_order=NULL,
                                         color_cells_by="pseudotime",
                                         trend_formula="~ splines::ns(pseudotime, df=3)",
                                         # label_by_short_name=TRUE,
                                         vertical_jitter=NULL,
                                         horizontal_jitter=NULL){
  
  genes <- as.list(rownames(cds_subset))
  
  # build df
  df <- data.frame(
    col.by = colData(cds_subset)[[color_cells_by]],
    pseudo = colData(cds_susbet)$pseudotime
  )
  df <- cbind(
    df,
    normalized_counds(cds_subset) # add log-normalized counts
  )
  
  # ggplot
  out.list <- lapply(
    genes,
    FUN = function(gene){
      ggplot(
        df,
        aes(x=pseudotime,y=~gene)
        ) + 
        geom_point() +
        scale_color_viridis_c() #TODO- add spline
    }
  )
  
  
  
}

#     with seurat object ####

#look at ghene expression over pseudotime, in seurat (pseudotime from monocle3)
seu_dotime <- function(
  seu,
  slot="data",
  genes=NULL,
  cells=NULL,
  col.by = "seurat_clusters",
  pseudotime.name="pseudotime",
  min.expr=0, #minimum expression value for plots
  trend.formula="~ splines::ns(pseudotime, df=3)",
  pt.size=1,
  alpha=1,
  line.color="#6B6B6B",
  line.size=1,
  line.alpha=1
){
  suppressMessages(library(ggformula))
  
  if(is.null(seu[[pseudotime.name]])){
    cat("No pseudotime added to the seurat object...\n")
    return(NULL)
  }
  if(is.null(cells)){
    cells <- colnames(seu)
  }
  
  
  df <- cbind(
      seu@meta.data,
      t(GetAssayData(seu,slot="data")[genes,])
    )
  df <- df[cells,] # subset based on selected cells
  
  
  # build plot
  tmp.gg <- ggplot(df, aes(x=pseudotime))
  
  out <- lapply(
    as.list(genes),
    FUN=function(X){
      return(
        tmp.gg +
        geom_point(
          alpha=alpha,
          size=pt.size,
          aes_(y=as.name(X), col=as.name(col.by))
        ) + 
          # geom_smooth( #TODO
          #   aes_(y=as.name(X), col=as.name(col.by)),
          #   formula= paste0("y",trend.formula), # same as monocle3 default
          #   color=line.color,
          #   size=line.size,
          #   alpha=line.alpha
          # )+
          geom_spline(#TODO: add expression filter
            
            aes_(y=as.name(X), col=as.name(col.by)),
            df=3, # same as monocle3 default
            color=line.color,
            size=line.size,
            alpha=line.alpha
          )+
          # scale_y_continuous(expand = c(0,0)) +
          # scale_x_continuous(expand=c(0,0)) +
          theme_minimal() +
          theme(
            axis.line = element_line(color="black"),
            axis.text = element_text(color="black"),
            axis.title = element_text(color="black", face="bold"),
            axis.ticks = element_line(color="black")
          )
        
      )
    }
  )
    
  
}


# SmartSeq Wrappers ####




# Generate a count matrix from a list of SmartSeq count vectors
# Input: 
#     count vector files (file names = sampleNames+countFileSuffix)
# Output: 
#     writes the count matrix to paste0(dataDir, newFileName)
SmartSeqGeneCounts <- function(sampleNames, 
                               countFileSuffix='_STAR_counts.tab', 
                               dataDir, 
                               STARref="/workdir/dwm269/genomes/mm10_STAR/",
                               newFileName="countMat.txt",
                               returnMat=TRUE,
                               verbose=TRUE){
  # Libraries ####
  suppressMessages(library(data.table))
  
  # Read  count vectors into a list ####
  countList <- list()
  for(i in 1:length(sampleNames)){
    countFile <- paste0(dataDir, sampleNames[i], countFileSuffix)
    
    # Count Mat Details:
    #   column 1: gene ID
    #   column 2: counts for unstranded RNA-seq
    #   column 3: counts for the 1st read strand aligned with RNA (htseq-count option -s yes)
    #   column 4: counts for the 2nd read strand aligned with RNA (htseq-count option -s reverse)
    if(file.exists(countFile)){
      countList[[i]] <- as.matrix(read.table(file=countFile,
                                             sep = '\t', 
                                             skip = 4
      )[,1:2]) #Only wnt gene IDs and unstranded counts
    }else{
      cat(countFile, " does not exist! Try again! \n")
      exit()
    }
    # Format list for merging
    rownames(countList[[i]]) <- countList[[i]][,1]
  }
  
  if(verbose){print("Samples loaded...")}
  
  # merge count vectors into a count matrix ####
  countMat <- as.matrix(as.numeric(countList[[1]][,2]))
  rownames(countMat) <- rownames(countList[[1]])
  if(verbose){print("Merging vectors...")}
  
  for(i in 2:length(countList)){
    
    #merge(x=countList)
    tmp = rownames(countMat)==rownames(countList[[i]])
    if(length(tmp[tmp==FALSE])==0){ #cbind if they have the same rownames
      countMat <- cbind(countMat, 
                        as.numeric(countList[[i]][,2])
      )
    }else{ #merge(0 if they don't -- this tkes wayyyy longer)
      # countMat <- merge(countMat, countList[[i]], )
    }
    if(verbose){
      # Progress bar; two ='s 
      if(i%%(length(countList)/10)==0){
        cat("==")
      }
      if(i==length(countList)){
        cat("==  Done! \n")
      }
    }
  }
  
  # dim(countMat)
  # rownames(countMat)
  # length(rownames(countMat)[is.na(rownames(countMat))])
  
  # Remove features with zero counts ####
  zeroFilter <- rowSums(countMat) 
  countMat <- subset(countMat,
                     subset = zeroFilter>0)
  
  if(file.exists(paste0(STARref,"geneInfo.tab"))){
    geneInfo <- read.table(file=paste0(STARref,"geneInfo.tab"),
                           sep='\t',
                           header = FALSE,
                           skip = 1)
  }else{
    print("STAR reference folder does not exist. Try again.")
    exit()
  }
  colnames(geneInfo)  <- c("ensembl_gene_id", "mgi_symbol", "Gene Type")
  rownames(geneInfo) <- geneInfo$ensembl_gene_id
  
  rownames(countMat) <- geneInfo[rownames(countMat),"mgi_symbol"]
  
  # Consolidate isoforms ####
  countMat <- countMat[unique(rownames(countMat)),]
  # ^^^ this should be changed to suum the duplicated rows
  
  
  # Set the col.names based on the sample SRR numbers ####
  colnames(countMat) <- sampleNames
  
  # Write the count matrix! ####
  write.table(x=countMat,
              file = paste0(dataDir,newFileName),
              sep='\t',
              row.names = TRUE,
              col.names = TRUE) 
  if(verbose){cat("Count matrix written to", paste0(dataDir,newFileName), '\n')}
  if(returnMat){
    return(countMat)
  }
}



# Misc. & Utils ####

strLoop <-function(string, repeats){
  out <- list()
  for(i in 1:repeats){
    out[[i]]<-string
  }
  return(out)
}

# Calculate the number of PCs that contain some proportion (95%) of the variance
#
npcs <- function(seu, var.toal=0.95, reduction="pca"){
  if(is.null(seu@reductions[[reduction]])){
    cat("Reduction", reduction, "not found!")
    return(NULL)
  }
  
  tmp.var <- (seu@reductions[[reduction]]@stdev)^2
  var.cut <- var.toal*sum(tmp.var)
  n.pcs=0
  var.sum = 0
  while(var.sum < var.cut){
    n.pcs = n.pcs + 1
    var.sum <- var.sum + tmp.var[n.pcs]
  }
  
  return(n.pcs)
}

# Chunk a large sparse matrix into a list for parallelization

spChunk <- function(spmat, nChunks){
  inds = round(seq(1, ncol(spmat), length.out=(nChunks+1)))
  out = list()
  
  out[[1]] <- spmat[,1:(inds[2])]
  for(i in 2:(length(inds)-1)){
    out[[i]] <- spmat[,(inds[i]+1):inds[i+1]]
  }
  
  return(out)
}

# calculate entropy across groups in a seurat object
#     output: returns data.frame ("group.by" rows by 1 col)
sc_entropy <- function(seu, group.by="sample", entropy.on="factorIDs", 
                       out.name=NULL, weighted=T, norm2one=T, verbose=T){
  group.levels <- unlist(unique(seu[[group.by]]))
  
  sub.meta <- seu@meta.data[,c(group.by,entropy.on)]
  
  entropy.out <- list()
  for(lev in group.levels){
    if(verbose){cat("calculating entropy for ", lev, "... ",sep = "")}
    tmp <- sub.meta[sub.meta[[group.by]]==lev,] # subset metadata by sample
    
    entro.levels <- unlist(unique(sub.meta[[entropy.on]]))
    
    perc <- table(tmp[[entropy.on]])/nrow(tmp) # find proportions for each entropy level
    if(weighted){
      w <- (table(sub.meta[[entropy.on]])/nrow(sub.meta))[perc!=0] # weights for present levels
    }else{
      w <- rep(1,length(table(sub.meta[[entropy.on]])))[perc!=0]   
    }
    
    perc <- perc[perc!=0] # remove zeroes
    
    entropy.out[[lev]] <- sum(-1*perc*log2(perc)*w) #calculate entropy
    
    if(verbose){cat("Done!\n",sep = "")}
  }
  
  # re-format entropy output
  if(is.null(out.name)){
    out.name <- paste0("entropy_",group.by,".by.",entropy.on)
  }
  entropy.out <- t(as.data.frame(entropy.out))
  colnames(entropy.out) <- out.name
  
  #replace NaN's with zeroes
  # entropy.out[is.nan(entropy.out)] <- 0
  
  if(norm2one){
    entropy.out <- entropy.out/log2(length(unique(sub.meta[[entropy.on]])))
  }
  
  return(entropy.out)
}
